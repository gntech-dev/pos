import { NextRequest, NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { getSessionFromCookie } from "@/lib/session"
import { NCFType } from "@/lib/ncf"

interface AlertData {
  type: string
  message: string
  severity: 'INFO' | 'WARNING' | 'CRITICAL' | 'DANGER'
  sequenceType: NCFType
  daysLeft?: number
  remaining?: number
  actionRequired: boolean
  autoGenerated: boolean
}

/**
 * GET /api/ncf/alerts - Get active NCF alerts
 */
export async function GET(_request: NextRequest) {
  const session = await getSessionFromCookie()
  if (!session) {
    return new NextResponse(JSON.stringify({ error: "Unauthorized" }), { status: 401 })
  }

  // Only admins and managers can access alerts
  if (!['ADMIN', 'MANAGER'].includes(session.role)) {
    return new NextResponse(JSON.stringify({ error: "Insufficient permissions" }), { status: 403 })
  }

  try {
    const sequences = await prisma.nCFSequence.findMany({
      orderBy: { type: 'asc' }
    })

    const now = new Date()
    const alerts: AlertData[] = []

    for (const sequence of sequences) {
      const expiryDate = new Date(sequence.expiryDate)
      const daysLeft = Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))
      const remaining = sequence.endNumber - sequence.currentNumber

      // Check for expired sequences
      if (daysLeft < 0) {
        alerts.push({
          type: 'EXPIRED',
          message: `La secuencia NCF ${sequence.type} ha EXPIRADO. Ya no se pueden generar más NCF de este tipo.`,
          severity: 'DANGER',
          sequenceType: sequence.type as NCFType,
          daysLeft,
          remaining,
          actionRequired: true,
          autoGenerated: true
        })
      }
      // Check for sequences expiring in 7 days or less (Critical)
      else if (daysLeft <= 7) {
        alerts.push({
          type: 'EXPIRING_SOON',
          message: `La secuencia NCF ${sequence.type} expira en ${daysLeft} día${daysLeft === 1 ? '' : 's'}. RENOVACIÓN URGENTE REQUERIDA.`,
          severity: 'CRITICAL',
          sequenceType: sequence.type as NCFType,
          daysLeft,
          remaining,
          actionRequired: true,
          autoGenerated: true
        })
      }
      // Check for sequences expiring in 30 days or less (Warning)
      else if (daysLeft <= 30) {
        alerts.push({
          type: 'EXPIRING_SOON',
          message: `La secuencia NCF ${sequence.type} expira en ${daysLeft} días. Considera renovar pronto.`,
          severity: 'WARNING',
          sequenceType: sequence.type as NCFType,
          daysLeft,
          remaining,
          actionRequired: true,
          autoGenerated: true
        })
      }

      // Check for low stock sequences
      if (remaining < 20) {
        const severity = remaining < 10 ? 'CRITICAL' : 'WARNING'
        alerts.push({
          type: 'LOW_STOCK',
          message: `La secuencia NCF ${sequence.type} tiene muy pocos números disponibles (${remaining} restantes).`,
          severity,
          sequenceType: sequence.type as NCFType,
          remaining,
          actionRequired: true,
          autoGenerated: true
        })
      } else if (remaining < 100) {
        alerts.push({
          type: 'LOW_STOCK',
          message: `La secuencia NCF ${sequence.type} tiene pocos números disponibles (${remaining} restantes).`,
          severity: 'WARNING',
          sequenceType: sequence.type as NCFType,
          remaining,
          actionRequired: true,
          autoGenerated: true
        })
      }

      // Check for exhausted sequences
      if (remaining <= 0) {
        alerts.push({
          type: 'EXHAUSTED',
          message: `La secuencia NCF ${sequence.type} se ha AGOTADO. No se pueden generar más NCF de este tipo.`,
          severity: 'DANGER',
          sequenceType: sequence.type as NCFType,
          remaining,
          actionRequired: true,
          autoGenerated: true
        })
      }
    }

    // Sort alerts by severity (DANGER > CRITICAL > WARNING > INFO)
    const severityOrder = { 'DANGER': 4, 'CRITICAL': 3, 'WARNING': 2, 'INFO': 1 }
    alerts.sort((a, b) => severityOrder[b.severity] - severityOrder[a.severity])

    return NextResponse.json({
      data: alerts,
      summary: {
        total: alerts.length,
        danger: alerts.filter(a => a.severity === 'DANGER').length,
        critical: alerts.filter(a => a.severity === 'CRITICAL').length,
        warning: alerts.filter(a => a.severity === 'WARNING').length,
        info: alerts.filter(a => a.severity === 'INFO').length
      },
      timestamp: now.toISOString()
    })
  } catch (error) {
    console.error('Error fetching NCF alerts:', error)
    return new NextResponse(JSON.stringify({ error: 'Server error' }), { status: 500 })
  }
}

/**
 * POST /api/ncf/alerts/check - Trigger alert check (simulates cron job)
 */
export async function POST(_request: NextRequest) {
  const session = await getSessionFromCookie()
  if (!session) {
    return new NextResponse(JSON.stringify({ error: "Unauthorized" }), { status: 401 })
  }

  // Only admins can trigger automated checks
  if (session.role !== 'ADMIN') {
    return new NextResponse(JSON.stringify({ error: "Insufficient permissions" }), { status: 403 })
  }

  try {
    const sequences = await prisma.nCFSequence.findMany()
    const now = new Date()
    const alerts: AlertData[] = []
    let criticalIssues = 0

    for (const sequence of sequences) {
      const expiryDate = new Date(sequence.expiryDate)
      const daysLeft = Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))
      const remaining = sequence.endNumber - sequence.currentNumber

      if (daysLeft < 0 || remaining <= 0) {
        criticalIssues++
      }

      // Generate alerts for critical issues
      if (daysLeft < 0) {
        alerts.push({
          type: 'EXPIRED',
          message: `CRÍTICO: Secuencia NCF ${sequence.type} EXPIRADA. Sistema pausado para este tipo.`,
          severity: 'DANGER',
          sequenceType: sequence.type as NCFType,
          daysLeft,
          remaining,
          actionRequired: true,
          autoGenerated: true
        })
      } else if (remaining <= 0) {
        alerts.push({
          type: 'EXHAUSTED',
          message: `CRÍTICO: Secuencia NCF ${sequence.type} AGOTADA. No se pueden generar más NCF.`,
          severity: 'DANGER',
          sequenceType: sequence.type as NCFType,
          remaining,
          actionRequired: true,
          autoGenerated: true
        })
      } else if (daysLeft <= 7) {
        alerts.push({
          type: 'EXPIRING_SOON',
          message: `URGENTE: NCF ${sequence.type} expira en ${daysLeft} días. Renovar inmediatamente.`,
          severity: 'CRITICAL',
          sequenceType: sequence.type as NCFType,
          daysLeft,
          remaining,
          actionRequired: true,
          autoGenerated: true
        })
      }
    }

    // Log the automated check
    await prisma.auditLog.create({
      data: {
        userId: session.userId,
        action: 'AUTO_CHECK',
        entity: 'NCF',
        entityId: 'alerts',
        newValue: JSON.stringify({
          alertsGenerated: alerts.length,
          criticalIssues,
          sequencesChecked: sequences.length,
          timestamp: now.toISOString()
        })
      }
    })

    // TODO: Here you could integrate with email notifications, SMS, or push notifications
    // For now, we just return the alerts

    return NextResponse.json({
      success: true,
      alerts,
      criticalIssues,
      sequencesChecked: sequences.length,
      timestamp: now.toISOString(),
      message: criticalIssues > 0 
        ? `Se detectaron ${criticalIssues} problema(s) crítico(s) que requieren atención inmediata.`
        : 'Verificación automática completada sin problemas críticos.'
    })
  } catch (error) {
    console.error('Error during automated NCF alert check:', error)
    return new NextResponse(JSON.stringify({ error: 'Server error' }), { status: 500 })
  }
}